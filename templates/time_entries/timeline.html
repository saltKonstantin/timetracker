{% extends "base.html" %}

{% block title %}Timeline - TimeTracker{% endblock %}

{% block content %}
<style>
    /* Multi-day entry styles */
    .time-entry.continues-next-day {
        border-bottom: none;
        border-bottom-left-radius: 0;
        border-bottom-right-radius: 0;
        position: relative;
    }
    
    .time-entry.continues-next-day::after {
        content: "‚ñº";
        position: absolute;
        bottom: 0;
        left: 50%;
        transform: translateX(-50%);
        color: rgba(0, 0, 0, 0.5);
    }
    
    .time-entry.continued-from-prev-day {
        border-top: none;
        border-top-left-radius: 0;
        border-top-right-radius: 0;
        position: relative;
    }
    
    .time-entry.continued-from-prev-day::before {
        content: "‚ñ≤";
        position: absolute;
        top: 0;
        left: 50%;
        transform: translateX(-50%);
        color: rgba(0, 0, 0, 0.5);
    }
    
    /* Category styles */
    .entry-category {
        font-size: 0.9rem;
        font-weight: bold;
        text-transform: uppercase;
        margin-bottom: 2px;
        color: #333;
    }
    
    /* Category colors */
    .time-entry[data-category="work"] {
        background-color: rgba(52, 152, 219, 0.8) !important;
    }
    
    .time-entry[data-category="personal"] {
        background-color: rgba(155, 89, 182, 0.8) !important;
    }
    
    .time-entry[data-category="meeting"] {
        background-color: rgba(231, 76, 60, 0.8) !important;
    }
    
    .time-entry[data-category="break"] {
        background-color: rgba(46, 204, 113, 0.8) !important;
    }
    
    .time-entry[data-category="admin"] {
        background-color: rgba(241, 196, 15, 0.8) !important;
    }
    
    .time-entry[data-category="development"] {
        background-color: rgba(52, 73, 94, 0.8) !important;
        color: white;
    }
    
    .time-entry[data-category="design"] {
        background-color: rgba(230, 126, 34, 0.8) !important;
    }
    
    .time-entry[data-category="research"] {
        background-color: rgba(26, 188, 156, 0.8) !important;
    }
    
    .time-entry[data-category="planning"] {
        background-color: rgba(149, 165, 166, 0.8) !important;
    }
    
    .time-entry[data-category="learning"] {
        background-color: rgba(211, 84, 0, 0.8) !important;
    }
    
    .time-entry[data-category="exercise"] {
        background-color: rgba(46, 204, 113, 0.8) !important;
    }
    
    .time-entry[data-category="reading"] {
        background-color: rgba(231, 76, 60, 0.8) !important;
    }
    
    .time-entry[data-category="writing"] {
        background-color: rgba(241, 196, 15, 0.8) !important;
    }
    
    .time-entry[data-category="travel"] {
        background-color: rgba(230, 126, 34, 0.8) !important;
    }
    
    .time-entry[data-category="other"] {
        background-color: rgba(189, 195, 199, 0.8) !important;
    }
    
    /* Entry popup styles */
    .entry-popup .modal-content {
        border-radius: 8px;
        box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        border: 1px solid rgba(0,0,0,0.1);
    }
    
    .entry-popup .modal-header {
        padding: 10px 15px;
        background-color: #f8f9fa;
        border-bottom: 1px solid #e9ecef;
    }
    
    .entry-popup .modal-body {
        padding: 15px;
    }
    
    .entry-popup .modal-footer {
        padding: 10px 15px;
        background-color: #f8f9fa;
        border-top: 1px solid #e9ecef;
    }
    
    /* Custom positioning for entry popup */
    .entry-popup .modal-dialog {
        transition: none !important;
    }
    
    /* Remove backdrop for entry popup */
    .modal.entry-popup-mode {
        background-color: transparent !important;
    }
</style>

<div class="row mb-4">
    <div class="col-md-6">
        <h1>Time Tracker</h1>
        <p class="lead">Welcome, {{ current_user.username }}!</p>
    </div>
    <div class="col-md-6 text-md-end">
        <div class="btn-group">
            <a href="{{ url_for('entries.timeline', date=(selected_date - timedelta(days=7)).strftime('%Y-%m-%d')) }}" class="btn btn-outline-primary">
                <span>&laquo; Previous Week</span>
            </a>
            <a href="{{ url_for('entries.timeline') }}" class="btn btn-outline-primary">Current Week</a>
            <a href="{{ url_for('entries.timeline', date=(selected_date + timedelta(days=7)).strftime('%Y-%m-%d')) }}" class="btn btn-outline-primary">
                <span>Next Week &raquo;</span>
            </a>
        </div>
    </div>
</div>

<div class="card">
    <div class="card-header d-flex justify-content-between align-items-center">
        <h2 class="h5 mb-0">Week of {{ week_start.strftime('%B %d') }} - {{ week_end.strftime('%B %d, %Y') }}</h2>
        <div>
            <button type="button" class="btn btn-sm btn-primary" data-bs-toggle="modal" data-bs-target="#newEntryModal">
                Add Time Entry
            </button>
        </div>
    </div>
    <div class="card-body">
        <div class="week-view-container">
            <div class="weekday-headers">
                <div class="time-header-spacer"></div>
                {% for day in weekdays %}
                <div class="weekday-header {% if day.date == today.date() %}today{% endif %}">
                    <div class="weekday-name">{{ day.strftime('%a') }}</div>
                    <div class="weekday-date">{{ day.strftime('%d %b') }}</div>
                </div>
                {% endfor %}
            </div>
            
            <div class="timeline-container">
                <div class="time-labels">
                    {% for hour in range(24) %}
                    <div class="hour-label">{{ "%02d:00"|format(hour) }}</div>
                    {% endfor %}
                </div>
                
                <div class="week-grid">
                    {% for day in weekdays %}
                    <div class="day-column" data-date="{{ day.strftime('%Y-%m-%d') }}">
                        {% for hour in range(24) %}
                            {% for minute in [0, 30] %}
                                <div class="time-slot" 
                                     data-hour="{{ hour }}" 
                                     data-minute="{{ minute }}"
                                     data-date="{{ day.strftime('%Y-%m-%d') }}"
                                     data-time="{{ '%02d:%02d'|format(hour, minute) }}">
                                </div>
                            {% endfor %}
                        {% endfor %}
                        
                        <div class="day-entries" id="entries-{{ day.strftime('%Y-%m-%d') }}">
                            <!-- Day entries will be inserted here by JavaScript -->
                        </div>
                    </div>
                    {% endfor %}
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Entry Info Modal -->
<div class="modal fade" id="entryInfoModal" tabindex="-1" aria-labelledby="entryInfoModalLabel" aria-hidden="true">
    <div class="modal-dialog entry-popup">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="entryInfoModalLabel">Edit Time Entry</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div id="entryViewMode">
                    <p><strong>Description:</strong> <span id="entryInfoDescription"></span></p>
                    <p><strong>Date:</strong> <span id="entryInfoDate"></span></p>
                    <p><strong>Start Time:</strong> <span id="entryInfoStartTime"></span></p>
                    <p><strong>End Time:</strong> <span id="entryInfoEndTime"></span></p>
                    <p><strong>Duration:</strong> <span id="entryInfoDuration"></span></p>
                </div>
                <div id="entryEditMode" style="display: none;">
                    <form id="editEntryForm" method="post">
                        <div class="mb-3">
                            <label for="editEntryCategory" class="form-label">Category</label>
                            <select class="form-control" id="editEntryCategory" name="category" required>
                                <option value="">Select a category</option>
                                <option value="work">üíº Work</option>
                                <option value="personal">üè† Personal</option>
                                <option value="meeting">üë• Meeting</option>
                                <option value="break">‚òï Break</option>
                                <option value="admin">üìã Administrative</option>
                                <option value="development">üíª Development</option>
                                <option value="design">üé® Design</option>
                                <option value="research">üîç Research</option>
                                <option value="planning">üìÖ Planning</option>
                                <option value="learning">üìö Learning</option>
                                <option value="exercise">üèãÔ∏è Exercise</option>
                                <option value="reading">üìñ Reading</option>
                                <option value="writing">‚úçÔ∏è Writing</option>
                                <option value="travel">‚úàÔ∏è Travel</option>
                                <option value="other">‚ùì Other</option>
                            </select>
                        </div>
                        <div class="mb-3">
                            <label for="editEntryDescription" class="form-label">Notes (Optional)</label>
                            <input type="text" class="form-control" id="editEntryDescription" name="description" placeholder="Additional details (optional)">
                        </div>
                        <div class="row">
                            <div class="col-md-6 mb-3">
                                <label for="editEntryStartTime" class="form-label">Start Time</label>
                                <input type="datetime-local" class="form-control" id="editEntryStartTime" name="start_time" required>
                            </div>
                            <div class="col-md-6 mb-3">
                                <label for="editEntryEndTime" class="form-label">End Time</label>
                                <input type="datetime-local" class="form-control" id="editEntryEndTime" name="end_time" required>
                            </div>
                        </div>
                        <div class="d-flex justify-content-between mt-3">
                            <button type="button" id="saveEntryBtn" class="btn btn-success">Save Changes</button>
                            <button type="button" id="deleteEntryBtn2" class="btn btn-danger">Delete</button>
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                        </div>
                    </form>
                </div>
            </div>
            <div class="modal-footer">
                <div id="entryViewButtons">
                    <button type="button" id="editModeBtn" class="btn btn-primary">Edit</button>
                    <button type="button" id="deleteEntryBtn" class="btn btn-danger">Delete</button>
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
                <div id="entryEditButtons" style="display: none;">
                    <button type="button" id="saveEntryBtn2" class="btn btn-success">Save</button>
                    <button type="button" id="cancelEditBtn" class="btn btn-secondary">Cancel</button>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Delete Confirmation Modal -->
<div class="modal fade" id="deleteModal" tabindex="-1" aria-labelledby="deleteModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="deleteModalLabel">Confirm Delete</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>Are you sure you want to delete the entry "<span id="deleteEntryName"></span>"?</p>
                <p class="text-danger">This action cannot be undone.</p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <form id="deleteForm" method="post" action="">
                    <button type="submit" class="btn btn-danger">Delete</button>
                </form>
            </div>
        </div>
    </div>
</div>

<!-- New Entry Modal -->
<div class="modal fade" id="newEntryModal" tabindex="-1" aria-labelledby="newEntryModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="newEntryModalLabel">Add New Time Entry</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <ul class="nav nav-tabs" id="entryTabs" role="tablist">
                    <li class="nav-item" role="presentation">
                        <button class="nav-link active" id="standard-tab" data-bs-toggle="tab" 
                                data-bs-target="#standard" type="button" role="tab" 
                                aria-controls="standard" aria-selected="true">Standard Entry</button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="quick-tab" data-bs-toggle="tab" 
                                data-bs-target="#quick" type="button" role="tab" 
                                aria-controls="quick" aria-selected="false">Quick Entry</button>
                    </li>
                </ul>
                <div class="tab-content pt-3" id="entryTabsContent">
                    <div class="tab-pane fade show active" id="standard" role="tabpanel" aria-labelledby="standard-tab">
                        <form method="post" action="{{ url_for('entries.create_entry') }}">
                            {{ entry_form.hidden_tag() }}
                            <div class="mb-3">
                                <label for="category" class="form-label">Category</label>
                                <select class="form-control" id="category" name="category" required>
                                    <option value="">Select a category</option>
                                    <option value="work">üíº Work</option>
                                    <option value="personal">üè† Personal</option>
                                    <option value="meeting">üë• Meeting</option>
                                    <option value="break">‚òï Break</option>
                                    <option value="admin">üìã Administrative</option>
                                    <option value="development">üíª Development</option>
                                    <option value="design">üé® Design</option>
                                    <option value="research">üîç Research</option>
                                    <option value="planning">üìÖ Planning</option>
                                    <option value="learning">üìö Learning</option>
                                    <option value="exercise">üèãÔ∏è Exercise</option>
                                    <option value="reading">üìñ Reading</option>
                                    <option value="writing">‚úçÔ∏è Writing</option>
                                    <option value="travel">‚úàÔ∏è Travel</option>
                                    <option value="other">‚ùì Other</option>
                                </select>
                            </div>
                            <div class="mb-3">
                                {{ entry_form.description.label(class="form-label") }}
                                {{ entry_form.description(class="form-control", placeholder="Additional details (optional)") }}
                                {% for error in entry_form.description.errors %}
                                    <span class="text-danger">{{ error }}</span>
                                {% endfor %}
                            </div>
                            <div class="row">
                                <div class="col-md-6 mb-3">
                                    {{ entry_form.start_time.label(class="form-label") }}
                                    {{ entry_form.start_time(class="form-control") }}
                                    {% for error in entry_form.start_time.errors %}
                                        <span class="text-danger">{{ error }}</span>
                                    {% endfor %}
                                </div>
                                <div class="col-md-6 mb-3">
                                    {{ entry_form.end_time.label(class="form-label") }}
                                    {{ entry_form.end_time(class="form-control") }}
                                    {% for error in entry_form.end_time.errors %}
                                        <span class="text-danger">{{ error }}</span>
                                    {% endfor %}
                                </div>
                            </div>
                            <div class="d-grid gap-2">
                                {{ entry_form.submit(class="btn btn-primary") }}
                            </div>
                        </form>
                    </div>
                    <div class="tab-pane fade" id="quick" role="tabpanel" aria-labelledby="quick-tab">
                        <form method="post" action="{{ url_for('entries.quick_entry') }}">
                            {{ quick_form.hidden_tag() }}
                            <div class="mb-3">
                                <label for="quick_category" class="form-label">Category</label>
                                <select class="form-control" id="quick_category" name="category" required>
                                    <option value="">Select a category</option>
                                    <option value="work">üíº Work</option>
                                    <option value="personal">üè† Personal</option>
                                    <option value="meeting">üë• Meeting</option>
                                    <option value="break">‚òï Break</option>
                                    <option value="admin">üìã Administrative</option>
                                    <option value="development">üíª Development</option>
                                    <option value="design">üé® Design</option>
                                    <option value="research">üîç Research</option>
                                    <option value="planning">üìÖ Planning</option>
                                    <option value="learning">üìö Learning</option>
                                    <option value="exercise">üèãÔ∏è Exercise</option>
                                    <option value="reading">üìñ Reading</option>
                                    <option value="writing">‚úçÔ∏è Writing</option>
                                    <option value="travel">‚úàÔ∏è Travel</option>
                                    <option value="other">‚ùì Other</option>
                                </select>
                            </div>
                            <div class="mb-3">
                                {{ quick_form.description.label(class="form-label") }}
                                {{ quick_form.description(class="form-control", placeholder="Additional details (optional)") }}
                                {% for error in quick_form.description.errors %}
                                    <span class="text-danger">{{ error }}</span>
                                {% endfor %}
                            </div>
                            <div class="mb-3">
                                {{ quick_form.duration.label(class="form-label") }}
                                {{ quick_form.duration(class="form-control", placeholder="e.g. 0.25 for 15 minutes, 1.5 for 1.5 hours") }}
                                <div class="form-text">Enter hours, e.g. 0.25 for 15 minutes, 1.5 for 1.5 hours</div>
                                {% for error in quick_form.duration.errors %}
                                    <span class="text-danger">{{ error }}</span>
                                {% endfor %}
                            </div>
                            <div class="d-grid gap-2">
                                {{ quick_form.submit(class="btn btn-primary") }}
                            </div>
                        </form>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- New Entry from Selection Modal -->
<div class="modal fade" id="newEntryFromSelectionModal" tabindex="-1" aria-labelledby="newEntryFromSelectionModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="newEntryFromSelectionModalLabel">Add New Time Entry</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <form id="newEntryFromSelectionForm" method="post" action="{{ url_for('entries.create_entry') }}">
                    {{ entry_form.hidden_tag() }}
                    <div class="mb-3">
                        <label for="selectionCategory" class="form-label">Category</label>
                        <select class="form-control" id="selectionCategory" name="category" required>
                            <option value="">Select a category</option>
                            <option value="work">üíº Work</option>
                            <option value="personal">üè† Personal</option>
                            <option value="meeting">üë• Meeting</option>
                            <option value="break">‚òï Break</option>
                            <option value="admin">üìã Administrative</option>
                            <option value="development">üíª Development</option>
                            <option value="design">üé® Design</option>
                            <option value="research">üîç Research</option>
                            <option value="planning">üìÖ Planning</option>
                            <option value="learning">üìö Learning</option>
                            <option value="exercise">üèãÔ∏è Exercise</option>
                            <option value="reading">üìñ Reading</option>
                            <option value="writing">‚úçÔ∏è Writing</option>
                            <option value="travel">‚úàÔ∏è Travel</option>
                            <option value="other">‚ùì Other</option>
                        </select>
                    </div>
                    <div class="mb-3">
                        {{ entry_form.description.label(class="form-label") }}
                        {{ entry_form.description(class="form-control", placeholder="Additional details (optional)") }}
                    </div>
                    <div class="row">
                        <div class="col-md-6 mb-3">
                            {{ entry_form.start_time.label(class="form-label") }}
                            {{ entry_form.start_time(class="form-control", id="selectionStartTime") }}
                        </div>
                        <div class="col-md-6 mb-3">
                            {{ entry_form.end_time.label(class="form-label") }}
                            {{ entry_form.end_time(class="form-control", id="selectionEndTime") }}
                        </div>
                    </div>
                    <div class="d-grid gap-2">
                        {{ entry_form.submit(class="btn btn-primary") }}
                    </div>
                </form>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Parse entries data from Jinja
        let allEntries = [];
        
        {% for entry in all_entries %}
        allEntries.push({
            id: {{ entry.id }},
            description: "{{ entry.description }}",
            category: "{{ entry.category if entry.category else 'other' }}",
            start_time: new Date("{{ entry.start_time.isoformat() }}"),
            end_time: new Date("{{ entry.end_time.isoformat() }}"),
            date: "{{ entry.start_time.strftime('%Y-%m-%d') }}",
            duration_minutes: {{ entry.duration }}
        });
        {% endfor %}
        
        // Group entries by date
        const entriesByDate = {};
        allEntries.forEach(entry => {
            if (!entriesByDate[entry.date]) {
                entriesByDate[entry.date] = [];
            }
            entriesByDate[entry.date].push(entry);
        });
        
        // Render entries for each day
        Object.keys(entriesByDate).forEach(date => {
            const dayEntries = document.getElementById(`entries-${date}`);
            if (dayEntries) {
                renderDayEntries(dayEntries, entriesByDate[date], date);
            }
        });
        
        // Selection state
        let isSelecting = false;
        let selectionStart = null;
        let selectionCurrentDay = null;
        let selectedSlots = [];
        
        // Drag state
        let isDragging = false;
        let isResizing = false;
        let draggedEntry = null;
        let dragStartY = 0;
        let originalEntryTop = 0;
        let resizeStartY = 0;
        let originalEntryHeight = 0;
        let entryStartTime = null;
        let entryEndTime = null;
        let entryDate = null;
        let isResizingTop = false;
        
        // Track if mouse has moved since mousedown
        let hasMoved = false;
        
        // Time slot selection
        const timeSlots = document.querySelectorAll('.time-slot');
        timeSlots.forEach(slot => {
            slot.addEventListener('mousedown', (e) => {
                // Reset hasMoved on mousedown
                hasMoved = false;
                
                // Make sure we're not clicking on an entry or already dragging/resizing
                if (e.button === 0 && !isDragging && !isResizing && !e.target.closest('.time-entry')) {
                    isSelecting = true;
                    selectionStart = slot;
                    selectionCurrentDay = slot.dataset.date;
                    clearSelection();
                    slot.classList.add('selected');
                    selectedSlots.push(slot);
                    
                    // Prevent event from bubbling to parent elements
                    e.stopPropagation();
                }
            });
            
            slot.addEventListener('mouseover', (e) => {
                if (isSelecting && slot.dataset.date === selectionCurrentDay) {
                    updateSelection(selectionStart, slot);
                }
            });
        });
        
        // Track mouse movement
        document.addEventListener('mousemove', () => {
            hasMoved = true;
        });
        
        document.addEventListener('mouseup', (e) => {
            if (isSelecting) {
                isSelecting = false;
                if (selectedSlots.length > 0) {
                    showNewEntryFromSelection();
                }
            }
            
            if (isDragging || isResizing) {
                isDragging = false;
                isResizing = false;
                
                if (draggedEntry) {
                    // Save the changes to the server
                    saveEntryChanges(draggedEntry);
                    draggedEntry = null;
                }
            }
            
            // Reset hasMoved after a short delay
            setTimeout(() => {
                hasMoved = false;
            }, 50);
        });
        
        // Render entries for a specific day
        function renderDayEntries(container, entries, date) {
            // Clear existing entries
            container.innerHTML = '';
            
            // Render each entry
            entries.forEach(entry => {
                const startHour = entry.start_time.getHours();
                const startMinute = entry.start_time.getMinutes();
                const endHour = entry.end_time.getHours();
                const endMinute = entry.end_time.getMinutes();
                
                // Calculate position and size
                const startPosition = (startHour * 2) + Math.floor(startMinute / 30);
                const endPosition = (endHour * 2) + Math.ceil(endMinute / 30);
                const entryLength = endPosition - startPosition;
                
                // Create entry element
                const entryEl = document.createElement('div');
                entryEl.className = 'time-entry';
                
                // Check if this is a multi-day entry
                const startDate = new Date(entry.date);
                const endDate = new Date(entry.end_time);
                startDate.setHours(0, 0, 0, 0);
                endDate.setHours(0, 0, 0, 0);
                const isMultiDayEntry = startDate.getTime() !== endDate.getTime();
                
                // For entries that start on this day
                if (date === entry.date) {
                    if (isMultiDayEntry) {
                        // If entry spans multiple days, extend to end of day
                        const endOfDayPosition = 24 * 2; // End of day (24 hours * 2 slots per hour)
                        const partialEntryLength = endOfDayPosition - startPosition;
                        entryEl.style.gridRow = `${startPosition + 1} / span ${partialEntryLength}`;
                        entryEl.classList.add('continues-next-day');
                        entryEl.dataset.isMultiDay = "true";
                        
                        // Store the original entry ID for the continuation entry
                        entryEl.dataset.entryId = entry.id;
                        
                        // Create continuation entries for subsequent days if they're in the current view
                        const nextDayDate = new Date(startDate);
                        nextDayDate.setDate(nextDayDate.getDate() + 1);
                        
                        // Check if the next day is within the end date
                        if (nextDayDate.getTime() <= endDate.getTime()) {
                            const nextDayDateStr = nextDayDate.toISOString().split('T')[0];
                            const nextDayColumn = document.querySelector(`.day-column[data-date="${nextDayDateStr}"]`);
                            
                            if (nextDayColumn) {
                                // Calculate the end position for the continuation entry
                                let continuationEndPosition;
                                
                                // If the entry ends on the next day
                                if (nextDayDate.getTime() === endDate.getTime()) {
                                    // End at the actual end time
                                    continuationEndPosition = endHour * 2 + Math.ceil(endMinute / 30);
                                } else {
                                    // Entry continues beyond the next day, so fill the entire day
                                    continuationEndPosition = 24 * 2;
                                }
                                
                                // Create a continuation entry in the next day column
                                createContinuationEntry(
                                    nextDayColumn, 
                                    entry, 
                                    0, // Start from beginning of day
                                    continuationEndPosition // End at the calculated position
                                );
                            }
                        }
                    } else {
                        // Normal single-day entry
                        entryEl.style.gridRow = `${startPosition + 1} / span ${entryLength}`;
                    }
                } 
                // For entries that end on this day but started on a previous day
                else if (date === endDate.toISOString().split('T')[0] && date !== entry.date) {
                    // Entry ends on this day but started on a previous day
                    entryEl.style.gridRow = `1 / span ${endPosition}`;
                    entryEl.classList.add('continued-from-prev-day');
                    entryEl.dataset.isMultiDay = "true";
                    
                    // Mark as a continuation entry
                    entryEl.dataset.isContinuation = "true";
                    entryEl.dataset.originalEntryId = entry.id;
                    entryEl.dataset.date = date;
                }
                // For entries that span this entire day (middle day of a multi-day entry)
                else if (isMultiDayEntry) {
                    const entryStartDate = new Date(entry.date);
                    const entryEndDate = new Date(entry.end_time);
                    const currentDate = new Date(date);
                    entryStartDate.setHours(0, 0, 0, 0);
                    entryEndDate.setHours(0, 0, 0, 0);
                    currentDate.setHours(0, 0, 0, 0);
                    
                    // Check if current date is between start and end dates
                    if (currentDate > entryStartDate && currentDate < entryEndDate) {
                        // This day is completely spanned by the entry
                        entryEl.style.gridRow = `1 / span ${24 * 2}`; // Full day
                        entryEl.classList.add('continued-from-prev-day');
                        entryEl.classList.add('continues-next-day');
                        entryEl.dataset.isMultiDay = "true";
                        
                        // Mark as a continuation entry
                        entryEl.dataset.isContinuation = "true";
                        entryEl.dataset.originalEntryId = entry.id;
                        entryEl.dataset.date = date;
                    } else {
                        // Skip this entry for days it doesn't belong to
                        return;
                    }
                } else {
                    // Skip this entry for days it doesn't belong to
                    return;
                }
                
                entryEl.style.backgroundColor = getRandomColor(entry.description);
                entryEl.dataset.entryId = entry.id;
                entryEl.dataset.category = entry.category || 'other';
                
                // Store ISO strings without timezone info for consistent handling
                entryEl.dataset.startTime = toLocalISOString(entry.start_time);
                entryEl.dataset.endTime = toLocalISOString(entry.end_time);
                entryEl.dataset.date = entry.date;
                
                // Determine the display time based on the entry type
                let displayStartTime, displayEndTime;
                
                if (entryEl.classList.contains('continued-from-prev-day')) {
                    // For continuation entries, start time is 00:00
                    displayStartTime = "00:00";
                } else {
                    // Normal start time
                    displayStartTime = formatTime(entry.start_time);
                }
                
                if (entryEl.classList.contains('continues-next-day')) {
                    // For entries that continue to next day, end time is 23:59
                    displayEndTime = "23:59";
                } else {
                    // Normal end time
                    displayEndTime = formatTime(entry.end_time);
                }
                
                // Make the entry clickable by adding a link
                entryEl.innerHTML = `
                    <div class="entry-resize-handle top-handle"></div>
                    <div class="entry-category">${getCategoryWithEmoji(entry.category || 'other')}</div>
                    <div class="entry-title">${entry.description}</div>
                    <div class="entry-time">${displayStartTime} - ${displayEndTime}</div>
                    <div class="entry-resize-handle bottom-handle"></div>
                `;
                
                // Add event listeners for dragging the entry
                entryEl.addEventListener('mousedown', (e) => {
                    // Reset hasMoved on mousedown
                    hasMoved = false;
                    
                    if (e.target.classList.contains('entry-resize-handle')) {
                        // Resize handling
                        e.stopPropagation();
                        e.preventDefault();
                        isResizing = true;
                        draggedEntry = entryEl;
                        resizeStartY = e.clientY;
                        originalEntryHeight = entryEl.offsetHeight;
                        entryStartTime = new Date(entryEl.dataset.startTime);
                        entryEndTime = new Date(entryEl.dataset.endTime);
                        entryDate = entryEl.dataset.date;
                        
                        // Determine if we're resizing from top or bottom
                        isResizingTop = e.target.classList.contains('top-handle');
                    } else if (!e.target.closest('a') && !e.target.closest('button')) {
                        // Drag handling (avoid when clicking links or buttons inside the entry)
                        e.stopPropagation();
                        e.preventDefault();
                        isDragging = true;
                        draggedEntry = entryEl;
                        dragStartY = e.clientY;
                        originalEntryTop = entryEl.offsetTop;
                        entryStartTime = new Date(entryEl.dataset.startTime);
                        entryEndTime = new Date(entryEl.dataset.endTime);
                        entryDate = entryEl.dataset.date;
                        
                        // Highlight the entry being dragged
                        entryEl.classList.add('dragging');
                    }
                });
                
                // Add click handler to show entry details in a popup
                entryEl.addEventListener('click', (e) => {
                    // Only show popup if we're not dragging or resizing and haven't moved the mouse
                    if (!hasMoved && !isDragging && !isResizing) {
                        e.stopPropagation();
                        
                        // Get the position of the clicked entry
                        const rect = entryEl.getBoundingClientRect();
                        const entryRight = rect.right;
                        const entryTop = rect.top;
                        
                        // If this is a continuation entry, find the original entry
                        if (entryEl.dataset.isContinuation === "true") {
                            const originalEntryId = entryEl.dataset.originalEntryId;
                            const originalEntry = allEntries.find(entry => entry.id == originalEntryId);
                            
                            if (originalEntry) {
                                // Show entry details in the modal and go directly to edit mode
                                showEntryDetails(originalEntry, true, { x: entryRight, y: entryTop });
                                return;
                            }
                        }
                        
                        // Show entry details in the modal and go directly to edit mode
                        showEntryDetails({
                            id: entry.id,
                            description: entry.description,
                            category: entry.category,
                            date: entry.date,
                            start_time: entry.start_time,
                            end_time: entry.end_time,
                            duration_minutes: entry.duration_minutes
                        }, true, { x: entryRight, y: entryTop });
                    }
                });
                
                container.appendChild(entryEl);
            });
        }
        
        // Helper function to create a continuation entry
        function createContinuationEntry(dayColumn, originalEntry, startPosition, endPosition) {
            const entryEl = document.createElement('div');
            entryEl.className = 'time-entry continued-from-prev-day';
            entryEl.style.gridRow = `${startPosition + 1} / span ${endPosition - startPosition}`;
            
            // Mark as a continuation entry
            entryEl.dataset.isContinuation = "true";
            entryEl.dataset.originalEntryId = originalEntry.id;
            entryEl.dataset.category = originalEntry.category || 'other';
            entryEl.dataset.date = dayColumn.dataset.date;
            
            // Store ISO strings without timezone info for consistent handling
            entryEl.dataset.startTime = toLocalISOString(originalEntry.start_time);
            entryEl.dataset.endTime = toLocalISOString(originalEntry.end_time);
            
            // Make the entry clickable by adding a link
            entryEl.innerHTML = `
                <div class="entry-resize-handle top-handle"></div>
                <div class="entry-category">${getCategoryWithEmoji(originalEntry.category || 'other')}</div>
                <div class="entry-title">${originalEntry.description}</div>
                <div class="entry-time">00:00 - ${formatTime(originalEntry.end_time)}</div>
                <div class="entry-resize-handle bottom-handle"></div>
            `;
            
            // Add the same event listeners as regular entries
            entryEl.addEventListener('mousedown', (e) => {
                // Reset hasMoved on mousedown
                hasMoved = false;
                
                if (e.target.classList.contains('entry-resize-handle')) {
                    // Resize handling for continuation entries
                    e.stopPropagation();
                    e.preventDefault();
                    isResizing = true;
                    draggedEntry = entryEl;
                    resizeStartY = e.clientY;
                    originalEntryHeight = entryEl.offsetHeight;
                    entryStartTime = new Date(entryEl.dataset.startTime);
                    entryEndTime = new Date(entryEl.dataset.endTime);
                    entryDate = dayColumn.dataset.date;
                    
                    // Determine if we're resizing from top or bottom
                    isResizingTop = e.target.classList.contains('top-handle');
                } else if (!e.target.closest('a') && !e.target.closest('button')) {
                    // Drag handling for continuation entries
                    e.stopPropagation();
                    e.preventDefault();
                    isDragging = true;
                    draggedEntry = entryEl;
                    dragStartY = e.clientY;
                    originalEntryTop = entryEl.offsetTop;
                    entryStartTime = new Date(entryEl.dataset.startTime);
                    entryEndTime = new Date(entryEl.dataset.endTime);
                    entryDate = dayColumn.dataset.date;
                    
                    // Highlight the entry being dragged
                    entryEl.classList.add('dragging');
                }
            });
            
            // Add click handler to show entry details in a popup
            entryEl.addEventListener('click', (e) => {
                // Only show popup if we're not dragging or resizing and haven't moved the mouse
                if (!hasMoved && !isDragging && !isResizing) {
                    e.stopPropagation();
                    
                    // Get the position of the clicked entry
                    const rect = entryEl.getBoundingClientRect();
                    const entryRight = rect.right;
                    const entryTop = rect.top;
                    
                    // Find the original entry data
                    const originalEntryId = entryEl.dataset.originalEntryId;
                    const originalEntry = allEntries.find(entry => entry.id == originalEntryId);
                    
                    if (originalEntry) {
                        // Show entry details in the modal and go directly to edit mode
                        showEntryDetails(originalEntry, true, { x: entryRight, y: entryTop });
                    }
                }
            });
            
            // Add to the day column
            const entriesContainer = dayColumn.querySelector('.day-entries');
            if (entriesContainer) {
                entriesContainer.appendChild(entryEl);
            }
            
            return entryEl;
        }
        
        // Handle mouse move for dragging and resizing
        document.addEventListener('mousemove', (e) => {
            if (isDragging && draggedEntry) {
                const deltaY = e.clientY - dragStartY;
                const slotHeight = 40; // Height of one 30-minute slot in pixels
                const slotsToMove = Math.round(deltaY / slotHeight);
                
                if (slotsToMove !== 0) {
                    // Calculate new times
                    const durationMs = entryEndTime.getTime() - entryStartTime.getTime();
                    const newStartTime = new Date(entryStartTime.getTime() + (slotsToMove * 30 * 60 * 1000));
                    const newEndTime = new Date(newStartTime.getTime() + durationMs);
                    
                    // Check if we've moved to a different day
                    const originalDate = new Date(entryDate);
                    const newDate = new Date(newStartTime);
                    newDate.setHours(0, 0, 0, 0);
                    originalDate.setHours(0, 0, 0, 0);
                    
                    // Update the element's position
                    const startHour = newStartTime.getHours();
                    const startMinute = newStartTime.getMinutes();
                    const endHour = newEndTime.getHours();
                    const endMinute = newEndTime.getMinutes();
                    
                    // If we're still on the same day, update the position
                    if (newDate.getTime() === originalDate.getTime()) {
                        const startPosition = (startHour * 2) + Math.floor(startMinute / 30);
                        const endPosition = (endHour * 2) + Math.ceil(endMinute / 30);
                        const entryLength = endPosition - startPosition;
                        
                        draggedEntry.style.gridRow = `${startPosition + 1} / span ${entryLength}`;
                    } else {
                        // We've moved to a different day, mark as multi-day
                        draggedEntry.dataset.isMultiDay = "true";
                        
                        // If we're moving to a previous day
                        if (newDate < originalDate) {
                            // Make it start from the beginning of the current day view
                            draggedEntry.style.gridRow = `1 / span ${24 * 2}`;
                            draggedEntry.classList.add('continued-from-prev-day');
                        } else {
                            // Moving to a next day, make it go to the end of the current day
                            const startPosition = (startHour * 2) + Math.floor(startMinute / 30);
                            const endOfDayPosition = 24 * 2; // End of day
                            const entryLength = endOfDayPosition - startPosition;
                            
                            draggedEntry.style.gridRow = `${startPosition + 1} / span ${entryLength}`;
                            draggedEntry.classList.add('continues-next-day');
                        }
                    }
                    
                    // Update the data attributes with ISO strings without timezone info
                    draggedEntry.dataset.startTime = toLocalISOString(newStartTime);
                    draggedEntry.dataset.endTime = toLocalISOString(newEndTime);
                    
                    // Update displayed time
                    const timeDisplay = draggedEntry.querySelector('.entry-time');
                    if (timeDisplay) {
                        timeDisplay.textContent = `${formatTime(newStartTime)} - ${formatTime(newEndTime)}`;
                    }
                    
                    // Reset drag start position
                    dragStartY = e.clientY;
                    entryStartTime = newStartTime;
                    entryEndTime = newEndTime;
                }
            } else if (isResizing && draggedEntry) {
                const deltaY = e.clientY - resizeStartY;
                const slotHeight = 40; // Height of one 30-minute slot in pixels
                const slotsToResize = Math.round(deltaY / slotHeight);
                
                if (slotsToResize !== 0) {
                    if (isResizingTop) {
                        // Resizing from the top - adjust start time
                        const newStartTime = new Date(entryStartTime.getTime() + (slotsToResize * 30 * 60 * 1000));
                        
                        // Make sure start time is not after end time
                        if (newStartTime < entryEndTime) {
                            // Check if we've moved to a different day
                            const originalStartDate = new Date(entryDate);
                            const newStartDate = new Date(newStartTime);
                            originalStartDate.setHours(0, 0, 0, 0);
                            newStartDate.setHours(0, 0, 0, 0);
                            
                            // If we're still on the same day, update the position
                            if (newStartDate.getTime() === originalStartDate.getTime()) {
                                const startHour = newStartTime.getHours();
                                const startMinute = newStartTime.getMinutes();
                                const endHour = entryEndTime.getHours();
                                const endMinute = entryEndTime.getMinutes();
                                
                                const startPosition = (startHour * 2) + Math.floor(startMinute / 30);
                                const endPosition = (endHour * 2) + Math.ceil(endMinute / 30);
                                const entryLength = endPosition - startPosition;
                                
                                draggedEntry.style.gridRow = `${startPosition + 1} / span ${entryLength}`;
                            } else {
                                // We've moved to a different day, mark as multi-day
                                draggedEntry.dataset.isMultiDay = "true";
                                
                                // If we're extending to a previous day
                                if (newStartDate < originalStartDate) {
                                    // Make it start from the beginning of the current day view
                                    draggedEntry.style.gridRow = `1 / span ${24 * 2}`;
                                    draggedEntry.classList.add('continued-from-prev-day');
                                }
                            }
                            
                            // Update the data attributes with ISO strings without timezone info
                            draggedEntry.dataset.startTime = toLocalISOString(newStartTime);
                            
                            // Update displayed time
                            const timeDisplay = draggedEntry.querySelector('.entry-time');
                            if (timeDisplay) {
                                timeDisplay.textContent = `${formatTime(newStartTime)} - ${formatTime(entryEndTime)}`;
                            }
                            
                            // Reset resize start position
                            resizeStartY = e.clientY;
                            entryStartTime = newStartTime;
                        }
                    } else {
                        // Resizing from the bottom - adjust end time
                        const newEndTime = new Date(entryEndTime.getTime() + (slotsToResize * 30 * 60 * 1000));
                        
                        // Make sure end time is not before start time
                        if (newEndTime > entryStartTime) {
                            // Check if we've moved to a different day
                            const originalEndDate = new Date(entryEndTime);
                            const newEndDate = new Date(newEndTime);
                            originalEndDate.setHours(0, 0, 0, 0);
                            newEndDate.setHours(0, 0, 0, 0);
                            
                            // If we're still on the same day, update the position
                            if (newEndDate.getTime() === originalEndDate.getTime()) {
                                const startHour = entryStartTime.getHours();
                                const startMinute = entryStartTime.getMinutes();
                                const endHour = newEndTime.getHours();
                                const endMinute = newEndTime.getMinutes();
                                
                                const startPosition = (startHour * 2) + Math.floor(startMinute / 30);
                                const endPosition = (endHour * 2) + Math.ceil(endMinute / 30);
                                const entryLength = endPosition - startPosition;
                                
                                draggedEntry.style.gridRow = `${startPosition + 1} / span ${entryLength}`;
                            } else {
                                // We've moved to a different day, mark as multi-day
                                draggedEntry.dataset.isMultiDay = "true";
                                
                                // If we're extending to the next day, make it go to the end of the current day
                                if (newEndDate > originalEndDate) {
                                    const startHour = entryStartTime.getHours();
                                    const startMinute = entryStartTime.getMinutes();
                                    
                                    const startPosition = (startHour * 2) + Math.floor(startMinute / 30);
                                    const endOfDayPosition = 24 * 2; // End of day
                                    const entryLength = endOfDayPosition - startPosition;
                                    
                                    // Apply continues-next-day class if not already present
                                    if (!draggedEntry.classList.contains('continues-next-day')) {
                                        draggedEntry.classList.add('continues-next-day');
                                    }
                                    
                                    // Update the current entry to extend to the end of the day
                                    draggedEntry.style.gridRow = `${startPosition + 1} / span ${entryLength}`;
                                    
                                    // Find the next day column
                                    const currentDayColumn = draggedEntry.closest('.day-column');
                                    const nextDayDate = new Date(entryDate);
                                    nextDayDate.setDate(nextDayDate.getDate() + 1);
                                    const nextDayDateStr = nextDayDate.toISOString().split('T')[0];
                                    const nextDayColumn = document.querySelector(`.day-column[data-date="${nextDayDateStr}"]`);
                                    
                                    // If the next day column exists in the current view
                                    if (nextDayColumn) {
                                        // Check if we already have a continuation entry
                                        const entryId = draggedEntry.dataset.entryId || draggedEntry.dataset.originalEntryId;
                                        let continuationEntry = nextDayColumn.querySelector(`.time-entry[data-original-entry-id="${entryId}"]`);
                                        
                                        if (!continuationEntry) {
                                            // Create a continuation entry in the next day column
                                            continuationEntry = document.createElement('div');
                                            continuationEntry.className = 'time-entry continued-from-prev-day';
                                            continuationEntry.dataset.originalEntryId = entryId;
                                            continuationEntry.dataset.isContinuation = "true";
                                            continuationEntry.dataset.category = draggedEntry.dataset.category;
                                            continuationEntry.dataset.startTime = draggedEntry.dataset.startTime;
                                            continuationEntry.dataset.endTime = toLocalISOString(newEndTime);
                                            continuationEntry.dataset.date = nextDayDateStr;
                                            
                                            // Copy the content from the original entry
                                            const description = draggedEntry.querySelector('.entry-title')?.textContent || '';
                                            const category = draggedEntry.dataset.category || 'other';
                                            
                                            continuationEntry.innerHTML = `
                                                <div class="entry-resize-handle top-handle"></div>
                                                <div class="entry-category">${getCategoryWithEmoji(category)}</div>
                                                <div class="entry-title">${description}</div>
                                                <div class="entry-time">00:00 - ${formatTime(newEndTime)}</div>
                                                <div class="entry-resize-handle bottom-handle"></div>
                                            `;
                                            
                                            // Add the same event listeners as regular entries
                                            continuationEntry.addEventListener('mousedown', (e) => {
                                                // Reset hasMoved on mousedown
                                                hasMoved = false;
                                                
                                                if (e.target.classList.contains('entry-resize-handle')) {
                                                    // Resize handling for continuation entries
                                                    e.stopPropagation();
                                                    e.preventDefault();
                                                    isResizing = true;
                                                    draggedEntry = continuationEntry;
                                                    resizeStartY = e.clientY;
                                                    originalEntryHeight = continuationEntry.offsetHeight;
                                                    entryStartTime = new Date(continuationEntry.dataset.startTime);
                                                    entryEndTime = new Date(continuationEntry.dataset.endTime);
                                                    entryDate = nextDayDateStr;
                                                    
                                                    // Determine if we're resizing from top or bottom
                                                    isResizingTop = e.target.classList.contains('top-handle');
                                                } else if (!e.target.closest('a') && !e.target.closest('button')) {
                                                    // Drag handling for continuation entries
                                                    e.stopPropagation();
                                                    e.preventDefault();
                                                    isDragging = true;
                                                    draggedEntry = continuationEntry;
                                                    dragStartY = e.clientY;
                                                    originalEntryTop = continuationEntry.offsetTop;
                                                    entryStartTime = new Date(continuationEntry.dataset.startTime);
                                                    entryEndTime = new Date(continuationEntry.dataset.endTime);
                                                    entryDate = nextDayDateStr;
                                                    
                                                    // Highlight the entry being dragged
                                                    continuationEntry.classList.add('dragging');
                                                }
                                            });
                                            
                                            // Add click handler to show entry details in a popup
                                            continuationEntry.addEventListener('click', (e) => {
                                                // Only show popup if we're not dragging or resizing and haven't moved the mouse
                                                if (!hasMoved && !isDragging && !isResizing) {
                                                    e.stopPropagation();
                                                    
                                                    // Get the position of the clicked entry
                                                    const rect = continuationEntry.getBoundingClientRect();
                                                    const entryRight = rect.right;
                                                    const entryTop = rect.top;
                                                    
                                                    // Find the original entry data
                                                    const originalEntryId = continuationEntry.dataset.originalEntryId;
                                                    const originalEntry = allEntries.find(entry => entry.id == originalEntryId);
                                                    
                                                    if (originalEntry) {
                                                        // Show entry details in the modal and go directly to edit mode
                                                        showEntryDetails(originalEntry, true, { x: entryRight, y: entryTop });
                                                    }
                                                }
                                            });
                                            
                                            // Add to the next day's entries container
                                            const nextDayEntries = nextDayColumn.querySelector('.day-entries');
                                            if (nextDayEntries) {
                                                nextDayEntries.appendChild(continuationEntry);
                                            }
                                        }
                                        
                                        // Calculate the end position in the next day
                                        const nextDayEndHour = newEndTime.getHours();
                                        const nextDayEndMinute = newEndTime.getMinutes();
                                        const nextDayEndPosition = (nextDayEndHour * 2) + Math.ceil(nextDayEndMinute / 30);
                                        
                                        // Update the continuation entry's position and size
                                        // Start from position 1 (00:00) and span to the end time
                                        continuationEntry.style.gridRow = `1 / span ${nextDayEndPosition}`;
                                        
                                        // Update the data attributes
                                        continuationEntry.dataset.endTime = toLocalISOString(newEndTime);
                                        
                                        // Update the displayed time
                                        const timeDisplay = continuationEntry.querySelector('.entry-time');
                                        if (timeDisplay) {
                                            timeDisplay.textContent = `00:00 - ${formatTime(newEndTime)}`;
                                        }
                                    }
                                }
                            }
                            
                            // Update the data attributes with ISO strings without timezone info
                            draggedEntry.dataset.endTime = toLocalISOString(newEndTime);
                            
                            // Update displayed time
                            const timeDisplay = draggedEntry.querySelector('.entry-time');
                            if (timeDisplay) {
                                timeDisplay.textContent = `${formatTime(entryStartTime)} - ${formatTime(newEndTime)}`;
                            }
                            
                            // Reset resize start position
                            resizeStartY = e.clientY;
                            entryEndTime = newEndTime;
                        }
                    }
                }
            }
        });
        
        // Save entry changes to the server
        function saveEntryChanges(entryEl) {
            const entryId = entryEl.dataset.entryId || entryEl.dataset.originalEntryId;
            const startTime = entryEl.dataset.startTime;
            let endTime = entryEl.dataset.endTime;
            const isMultiDay = entryEl.dataset.isMultiDay === "true";
            const isContinuation = entryEl.dataset.isContinuation === "true";
            const category = entryEl.dataset.category || 'other';
            
            // Remove the dragging class
            entryEl.classList.remove('dragging');
            
            // For multi-day entries, find the continuation entry to get the correct end time
            if (isMultiDay && entryEl.classList.contains('continues-next-day')) {
                // Get the date of the current entry
                const currentDate = new Date(entryEl.dataset.date || entryEl.closest('.day-column').dataset.date);
                
                // Calculate the next day's date
                const nextDayDate = new Date(currentDate);
                nextDayDate.setDate(nextDayDate.getDate() + 1);
                const nextDayDateStr = nextDayDate.toISOString().split('T')[0];
                
                // Find the continuation entry in the next day column
                const nextDayColumn = document.querySelector(`.day-column[data-date="${nextDayDateStr}"]`);
                if (nextDayColumn) {
                    const continuationEntry = nextDayColumn.querySelector(`.time-entry[data-original-entry-id="${entryId}"]`);
                    if (continuationEntry) {
                        // Use the end time from the continuation entry
                        const continuationEndTime = continuationEntry.dataset.endTime;
                        if (continuationEndTime) {
                            endTime = continuationEndTime;
                        }
                    }
                }
            }
            
            // If this is a continuation entry, we need to find the original entry
            // and update its end time
            if (isContinuation) {
                const originalEntryId = entryEl.dataset.originalEntryId;
                if (originalEntryId) {
                    // Find the original entry in the DOM
                    const originalEntry = document.querySelector(`.time-entry[data-entry-id="${originalEntryId}"]`);
                    if (originalEntry) {
                        // Update the original entry's end time
                        originalEntry.dataset.endTime = endTime;
                        
                        // Send the update to the server with the original entry's start time
                        // and this continuation entry's end time
                        sendEntryUpdate(originalEntryId, category, originalEntry.dataset.startTime, endTime, true);
                        return;
                    }
                }
                
                // If we couldn't find the original entry, just use this entry's data
                sendEntryUpdate(originalEntryId || entryId, category, startTime, endTime, isMultiDay);
                return;
            }
            
            // For regular entries or if we couldn't find a continuation entry
            sendEntryUpdate(entryId, category, startTime, endTime, isMultiDay);
        }
        
        // Send the entry update to the server
        function sendEntryUpdate(entryId, category, startTime, endTime, isMultiDay) {
            fetch('/entry/update', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': '{{ csrf_token() if csrf_token else "" }}'
                },
                body: JSON.stringify({
                    id: entryId,
                    category: category,
                    start_time: startTime,
                    end_time: endTime
                })
            })
            .then(response => response.json())
            .then(data => {
                if (!data.success) {
                    console.error('Failed to update entry:', data.message);
                    // Silently reload the page without showing an alert
                    window.location.reload();
                } else if (isMultiDay) {
                    // If this is a multi-day entry, reload the page to show it properly across days
                    window.location.reload();
                }
            })
            .catch(error => {
                console.error('Error updating entry:', error);
                // Silently reload the page without showing an alert
                window.location.reload();
            });
        }
        
        // Clear current selection
        function clearSelection() {
            selectedSlots.forEach(slot => {
                slot.classList.remove('selected');
            });
            selectedSlots = [];
        }
        
        // Update selection between two slots
        function updateSelection(startSlot, endSlot) {
            clearSelection();
            
            const startHour = parseInt(startSlot.dataset.hour);
            const startMinute = parseInt(startSlot.dataset.minute);
            const endHour = parseInt(endSlot.dataset.hour);
            const endMinute = parseInt(endSlot.dataset.minute);
            const date = startSlot.dataset.date;
            
            // Determine direction
            let start, end;
            if (startHour * 60 + startMinute <= endHour * 60 + endMinute) {
                start = { hour: startHour, minute: startMinute };
                end = { hour: endHour, minute: endMinute };
            } else {
                start = { hour: endHour, minute: endMinute };
                end = { hour: startHour, minute: startMinute };
            }
            
            // Select all slots in range
            document.querySelectorAll(`.time-slot[data-date="${date}"]`).forEach(slot => {
                const hour = parseInt(slot.dataset.hour);
                const minute = parseInt(slot.dataset.minute);
                
                if ((hour > start.hour || (hour === start.hour && minute >= start.minute)) && 
                    (hour < end.hour || (hour === end.hour && minute <= end.minute))) {
                    slot.classList.add('selected');
                    selectedSlots.push(slot);
                }
            });
        }
        
        // Get a deterministic color based on string
        function getRandomColor(str) {
            // If we're using category colors, return a transparent color
            return 'rgba(0, 0, 0, 0.0)';
            
            // This code is kept for backward compatibility but not used
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = str.charCodeAt(i) + ((hash << 5) - hash);
            }
            
            const hue = hash % 360;
            return `hsla(${hue}, 70%, 80%, 0.8)`;
        }
        
        // Format time as HH:MM
        function formatTime(date) {
            return date.toTimeString().substring(0, 5);
        }
        
        // Format date as YYYY-MM-DD
        function formatDate(date) {
            return date.toISOString().split('T')[0];
        }
        
        // Convert a Date object to ISO string without timezone info
        function toLocalISOString(date) {
            // Create a new date object to avoid modifying the original
            const d = new Date(date);
            
            // Format as YYYY-MM-DDTHH:MM:SS
            const year = d.getFullYear();
            const month = String(d.getMonth() + 1).padStart(2, '0');
            const day = String(d.getDate()).padStart(2, '0');
            const hours = String(d.getHours()).padStart(2, '0');
            const minutes = String(d.getMinutes()).padStart(2, '0');
            const seconds = String(d.getSeconds()).padStart(2, '0');
            
            return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}`;
        }
        
        // Helper function to get category with emoji
        function getCategoryWithEmoji(category) {
            const categoryMap = {
                'work': 'üíº Work',
                'personal': 'üè† Personal',
                'meeting': 'üë• Meeting',
                'break': '‚òï Break',
                'admin': 'üìã Admin',
                'development': 'üíª Dev',
                'design': 'üé® Design',
                'research': 'üîç Research',
                'planning': 'üìÖ Planning',
                'learning': 'üìö Learning',
                'exercise': 'üèãÔ∏è Exercise',
                'reading': 'üìñ Reading',
                'writing': '‚úçÔ∏è Writing',
                'travel': '‚úàÔ∏è Travel',
                'other': '‚ùì Other'
            };
            
            return categoryMap[category] || categoryMap['other'];
        }
        
        // Show entry details in modal
        function showEntryDetails(entry, showEditMode = false, position = null) {
            // Store the current entry ID in the modal for reference
            const modal = document.getElementById('entryInfoModal');
            modal.dataset.entryId = entry.id;
            
            // Add a class to the modal for custom styling when using popup mode
            if (position) {
                modal.classList.add('entry-popup-mode');
            } else {
                modal.classList.remove('entry-popup-mode');
            }
            
            // Populate view mode fields
            document.getElementById('entryInfoDescription').textContent = entry.description;
            document.getElementById('entryInfoDate').textContent = new Date(entry.date).toLocaleDateString();
            document.getElementById('entryInfoStartTime').textContent = formatTime(entry.start_time);
            document.getElementById('entryInfoEndTime').textContent = formatTime(entry.end_time);
            
            // Calculate duration in hours and minutes
            const hours = Math.floor(entry.duration_minutes / 60);
            const minutes = entry.duration_minutes % 60;
            document.getElementById('entryInfoDuration').textContent = 
                `${hours > 0 ? hours + ' hour' + (hours > 1 ? 's' : '') : ''} ${minutes > 0 ? minutes + ' minute' + (minutes > 1 ? 's' : '') : ''}`.trim();
            
            // Populate edit mode fields
            document.getElementById('editEntryCategory').value = entry.category;
            document.getElementById('editEntryDescription').value = entry.description;
            
            // Format for datetime-local input
            const formatForInput = (date) => {
                const localISOString = new Date(date.getTime() - (date.getTimezoneOffset() * 60000))
                    .toISOString()
                    .substring(0, 16);
                return localISOString;
            };
            
            document.getElementById('editEntryStartTime').value = formatForInput(entry.start_time);
            document.getElementById('editEntryEndTime').value = formatForInput(entry.end_time);
            
            // Set up delete button
            const deleteBtn = document.getElementById('deleteEntryBtn');
            const deleteBtn2 = document.getElementById('deleteEntryBtn2');
            
            const setupDeleteButton = (btn) => {
                btn.onclick = () => {
                    document.getElementById('deleteEntryName').textContent = entry.description;
                    document.getElementById('deleteForm').action = `/entry/${entry.id}/delete`;
                    
                    const entryInfoModal = bootstrap.Modal.getInstance(document.getElementById('entryInfoModal'));
                    entryInfoModal.hide();
                    
                    const deleteModal = new bootstrap.Modal(document.getElementById('deleteModal'));
                    deleteModal.show();
                };
            };
            
            setupDeleteButton(deleteBtn);
            setupDeleteButton(deleteBtn2);
            
            // Set up edit mode button
            const editModeBtn = document.getElementById('editModeBtn');
            editModeBtn.onclick = () => {
                // Switch to edit mode
                document.getElementById('entryViewMode').style.display = 'none';
                document.getElementById('entryEditMode').style.display = 'block';
                document.getElementById('entryViewButtons').style.display = 'none';
                document.getElementById('entryEditButtons').style.display = 'block';
            };
            
            // Set up save button
            const saveEntryBtn = document.getElementById('saveEntryBtn');
            const saveEntryBtn2 = document.getElementById('saveEntryBtn2');
            
            const setupSaveButton = (btn) => {
                btn.onclick = () => {
                    // Get values from form
                    const category = document.getElementById('editEntryCategory').value;
                    const description = document.getElementById('editEntryDescription').value;
                    const startTime = document.getElementById('editEntryStartTime').value;
                    const endTime = document.getElementById('editEntryEndTime').value;
                    
                    // Convert to ISO strings while preserving local time
                    // This prevents the timezone shift when saving without changes
                    const startDate = new Date(startTime);
                    const endDate = new Date(endTime);
                    const startTimeISO = toLocalISOString(startDate);
                    const endTimeISO = toLocalISOString(endDate);
                    
                    // Send update to server
                    fetch('/entry/update', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': '{{ csrf_token() if csrf_token else "" }}'
                        },
                        body: JSON.stringify({
                            id: entry.id,
                            category: category,
                            description: description,
                            start_time: startTimeISO,
                            end_time: endTimeISO
                        })
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            // Close the modal and reload the page to show updated entries
                            const entryInfoModal = bootstrap.Modal.getInstance(document.getElementById('entryInfoModal'));
                            entryInfoModal.hide();
                            window.location.reload();
                        } else {
                            console.error('Failed to update entry:', data.message);
                            alert('Failed to update entry: ' + data.message);
                        }
                    })
                    .catch(error => {
                        console.error('Error updating entry:', error);
                        alert('Error updating entry. Please try again.');
                    });
                };
            };
            
            setupSaveButton(saveEntryBtn);
            setupSaveButton(saveEntryBtn2);
            
            // Show in edit mode directly if requested
            if (showEditMode) {
                document.getElementById('entryViewMode').style.display = 'none';
                document.getElementById('entryEditMode').style.display = 'block';
                document.getElementById('entryViewButtons').style.display = 'none';
                document.getElementById('entryEditButtons').style.display = 'block';
            } else {
                // Reset to view mode when opening
                document.getElementById('entryViewMode').style.display = 'block';
                document.getElementById('entryEditMode').style.display = 'none';
                document.getElementById('entryViewButtons').style.display = 'block';
                document.getElementById('entryEditButtons').style.display = 'none';
            }
            
            // Show the modal
            const modalInstance = new bootstrap.Modal(modal);
            modalInstance.show();
            
            // Position the modal next to the entry if position is provided
            if (position) {
                // Wait for the modal to be fully visible
                setTimeout(() => {
                    const modalDialog = modal.querySelector('.modal-dialog');
                    
                    // Calculate position to ensure the modal stays within viewport
                    const viewportWidth = window.innerWidth;
                    const viewportHeight = window.innerHeight;
                    const modalWidth = modalDialog.offsetWidth;
                    const modalHeight = modalDialog.offsetHeight;
                    
                    // Position to the right of the entry, with fallback to left if not enough space
                    let left = position.x + 10; // 10px offset from entry
                    if (left + modalWidth > viewportWidth) {
                        left = Math.max(0, position.x - modalWidth - 10);
                    }
                    
                    // Center vertically relative to the entry position
                    let top = position.y - (modalHeight / 2);
                    // Ensure modal stays within viewport
                    top = Math.max(10, Math.min(viewportHeight - modalHeight - 10, top));
                    
                    // Apply custom positioning
                    modalDialog.style.position = 'absolute';
                    modalDialog.style.margin = '0';
                    modalDialog.style.left = `${left}px`;
                    modalDialog.style.top = `${top}px`;
                    
                    // Ensure the modal backdrop doesn't interfere with our custom positioning
                    modal.style.paddingLeft = '0';
                    modal.style.paddingRight = '0';
                    
                    // Focus on the description field
                    document.getElementById('editEntryDescription').focus();
                }, 150);
            }
        }
        
        // Show new entry modal with selection times pre-filled
        function showNewEntryFromSelection() {
            if (selectedSlots.length === 0) return;
            
            // Find first and last selected slots
            let firstSlot = selectedSlots[0];
            let lastSlot = selectedSlots[selectedSlots.length - 1];
            
            const firstHour = parseInt(firstSlot.dataset.hour);
            const firstMinute = parseInt(firstSlot.dataset.minute);
            const lastHour = parseInt(lastSlot.dataset.hour);
            const lastMinute = parseInt(lastSlot.dataset.minute);
            const date = firstSlot.dataset.date;
            
            // Add 30 minutes to the last slot to get end time
            let endHour = lastHour;
            let endMinute = lastMinute + 30;
            if (endMinute >= 60) {
                endHour++;
                endMinute = 0;
            }
            
            // Set the form values
            const startDateTime = new Date(date);
            startDateTime.setHours(firstHour, firstMinute, 0);
            
            const endDateTime = new Date(date);
            endDateTime.setHours(endHour, endMinute, 0);
            
            // Format for datetime-local input
            const formatForInput = (date) => {
                const localISOString = new Date(date.getTime() - (date.getTimezoneOffset() * 60000))
                    .toISOString()
                    .substring(0, 16);
                return localISOString;
            };
            
            document.getElementById('selectionStartTime').value = formatForInput(startDateTime);
            document.getElementById('selectionEndTime').value = formatForInput(endDateTime);
            
            // Clear the description field and set focus to category
            const descriptionField = document.querySelector('#newEntryFromSelectionForm input[name="description"]');
            if (descriptionField) {
                descriptionField.value = '';
            }
            
            // Set focus to the category dropdown
            const categoryField = document.getElementById('selectionCategory');
            if (categoryField) {
                categoryField.value = '';
                setTimeout(() => categoryField.focus(), 100);
            }
            
            // Show the modal
            const modal = new bootstrap.Modal(document.getElementById('newEntryFromSelectionModal'));
            modal.show();
            
            // For debugging
            console.log('Showing new entry modal with:', {
                startTime: formatForInput(startDateTime),
                endTime: formatForInput(endDateTime),
                slots: selectedSlots.length
            });
        }
        // Get z-index correct (entries above slots)
           document.querySelectorAll('.day-entries').forEach(container => {
               container.style.zIndex = 5;
           });
           
           // Debug output for time slots
           console.log('Time slots initialized:', timeSlots.length);
           
           // Log click on time slots for debugging
           timeSlots.forEach(slot => {
               slot.addEventListener('click', (e) => {
                   if (!e.target.closest('.time-entry')) {
                       console.log('Clicked slot:', slot.dataset.date, slot.dataset.time);
                   }
               });
           });
       });
   </script>
{% endblock %}