{% extends "base.html" %}

{% block title %}Timeline - TimeTracker{% endblock %}

{% block content %}
<div class="row mb-4">
    <div class="col-md-6">
        <h1>Time Tracker</h1>
        <p class="lead">Welcome, {{ current_user.username }}!</p>
    </div>
    <div class="col-md-6 text-md-end">
        <div class="btn-group">
            <a href="{{ url_for('entries.timeline', date=(selected_date - timedelta(days=7)).strftime('%Y-%m-%d')) }}" class="btn btn-outline-primary">
                <span>&laquo; Previous Week</span>
            </a>
            <a href="{{ url_for('entries.timeline') }}" class="btn btn-outline-primary">Current Week</a>
            <a href="{{ url_for('entries.timeline', date=(selected_date + timedelta(days=7)).strftime('%Y-%m-%d')) }}" class="btn btn-outline-primary">
                <span>Next Week &raquo;</span>
            </a>
        </div>
    </div>
</div>

<div class="card">
    <div class="card-header d-flex justify-content-between align-items-center">
        <h2 class="h5 mb-0">Week of {{ week_start.strftime('%B %d') }} - {{ week_end.strftime('%B %d, %Y') }}</h2>
        <div>
            <a href="{{ url_for('entries.dashboard', date=selected_date.strftime('%Y-%m-%d')) }}" class="btn btn-sm btn-outline-secondary me-2">
                List View
            </a>
            <button type="button" class="btn btn-sm btn-primary" data-bs-toggle="modal" data-bs-target="#newEntryModal">
                Add Time Entry
            </button>
        </div>
    </div>
    <div class="card-body">
        <div class="week-view-container">
            <div class="weekday-headers">
                <div class="time-header-spacer"></div>
                {% for day in weekdays %}
                <div class="weekday-header {% if day.date == today.date() %}today{% endif %}">
                    <div class="weekday-name">{{ day.strftime('%a') }}</div>
                    <div class="weekday-date">{{ day.strftime('%d %b') }}</div>
                </div>
                {% endfor %}
            </div>
            
            <div class="timeline-container">
                <div class="time-labels">
                    {% for hour in range(24) %}
                    <div class="hour-label">{{ "%02d:00"|format(hour) }}</div>
                    {% endfor %}
                </div>
                
                <div class="week-grid">
                    {% for day in weekdays %}
                    <div class="day-column" data-date="{{ day.strftime('%Y-%m-%d') }}">
                        {% for hour in range(24) %}
                            {% for minute in [0, 15, 30, 45] %}
                                <div class="time-slot" 
                                     data-hour="{{ hour }}" 
                                     data-minute="{{ minute }}"
                                     data-date="{{ day.strftime('%Y-%m-%d') }}"
                                     data-time="{{ '%02d:%02d'|format(hour, minute) }}">
                                </div>
                            {% endfor %}
                        {% endfor %}
                        
                        <div class="day-entries" id="entries-{{ day.strftime('%Y-%m-%d') }}">
                            <!-- Day entries will be inserted here by JavaScript -->
                        </div>
                    </div>
                    {% endfor %}
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Entry Info Modal -->
<div class="modal fade" id="entryInfoModal" tabindex="-1" aria-labelledby="entryInfoModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="entryInfoModalLabel">Entry Details</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p><strong>Description:</strong> <span id="entryInfoDescription"></span></p>
                <p><strong>Date:</strong> <span id="entryInfoDate"></span></p>
                <p><strong>Start Time:</strong> <span id="entryInfoStartTime"></span></p>
                <p><strong>End Time:</strong> <span id="entryInfoEndTime"></span></p>
                <p><strong>Duration:</strong> <span id="entryInfoDuration"></span></p>
            </div>
            <div class="modal-footer">
                <a href="#" id="editEntryLink" class="btn btn-primary">Edit</a>
                <button type="button" id="deleteEntryBtn" class="btn btn-danger">Delete</button>
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>

<!-- Delete Confirmation Modal -->
<div class="modal fade" id="deleteModal" tabindex="-1" aria-labelledby="deleteModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="deleteModalLabel">Confirm Delete</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>Are you sure you want to delete the entry "<span id="deleteEntryName"></span>"?</p>
                <p class="text-danger">This action cannot be undone.</p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <form id="deleteForm" method="post" action="">
                    <button type="submit" class="btn btn-danger">Delete</button>
                </form>
            </div>
        </div>
    </div>
</div>

<!-- New Entry Modal -->
<div class="modal fade" id="newEntryModal" tabindex="-1" aria-labelledby="newEntryModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="newEntryModalLabel">Add New Time Entry</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <ul class="nav nav-tabs" id="entryTabs" role="tablist">
                    <li class="nav-item" role="presentation">
                        <button class="nav-link active" id="standard-tab" data-bs-toggle="tab" 
                                data-bs-target="#standard" type="button" role="tab" 
                                aria-controls="standard" aria-selected="true">Standard Entry</button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="quick-tab" data-bs-toggle="tab" 
                                data-bs-target="#quick" type="button" role="tab" 
                                aria-controls="quick" aria-selected="false">Quick Entry</button>
                    </li>
                </ul>
                <div class="tab-content pt-3" id="entryTabsContent">
                    <div class="tab-pane fade show active" id="standard" role="tabpanel" aria-labelledby="standard-tab">
                        <form method="post" action="{{ url_for('entries.create_entry') }}">
                            {{ entry_form.hidden_tag() }}
                            <div class="mb-3">
                                {{ entry_form.description.label(class="form-label") }}
                                {{ entry_form.description(class="form-control") }}
                                {% for error in entry_form.description.errors %}
                                    <span class="text-danger">{{ error }}</span>
                                {% endfor %}
                            </div>
                            <div class="row">
                                <div class="col-md-6 mb-3">
                                    {{ entry_form.start_time.label(class="form-label") }}
                                    {{ entry_form.start_time(class="form-control") }}
                                    {% for error in entry_form.start_time.errors %}
                                        <span class="text-danger">{{ error }}</span>
                                    {% endfor %}
                                </div>
                                <div class="col-md-6 mb-3">
                                    {{ entry_form.end_time.label(class="form-label") }}
                                    {{ entry_form.end_time(class="form-control") }}
                                    {% for error in entry_form.end_time.errors %}
                                        <span class="text-danger">{{ error }}</span>
                                    {% endfor %}
                                </div>
                            </div>
                            <div class="d-grid gap-2">
                                {{ entry_form.submit(class="btn btn-primary") }}
                            </div>
                        </form>
                    </div>
                    <div class="tab-pane fade" id="quick" role="tabpanel" aria-labelledby="quick-tab">
                        <form method="post" action="{{ url_for('entries.quick_entry') }}">
                            {{ quick_form.hidden_tag() }}
                            <div class="mb-3">
                                {{ quick_form.description.label(class="form-label") }}
                                {{ quick_form.description(class="form-control") }}
                                {% for error in quick_form.description.errors %}
                                    <span class="text-danger">{{ error }}</span>
                                {% endfor %}
                            </div>
                            <div class="mb-3">
                                {{ quick_form.duration.label(class="form-label") }}
                                {{ quick_form.duration(class="form-control", placeholder="e.g. 0.25 for 15 minutes, 1.5 for 1.5 hours") }}
                                <div class="form-text">Enter hours, e.g. 0.25 for 15 minutes, 1.5 for 1.5 hours</div>
                                {% for error in quick_form.duration.errors %}
                                    <span class="text-danger">{{ error }}</span>
                                {% endfor %}
                            </div>
                            <div class="d-grid gap-2">
                                {{ quick_form.submit(class="btn btn-primary") }}
                            </div>
                        </form>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- New Entry from Selection Modal -->
<div class="modal fade" id="newEntryFromSelectionModal" tabindex="-1" aria-labelledby="newEntryFromSelectionModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="newEntryFromSelectionModalLabel">Add New Time Entry</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <form id="newEntryFromSelectionForm" method="post" action="{{ url_for('entries.create_entry') }}">
                    {{ entry_form.hidden_tag() }}
                    <div class="mb-3">
                        {{ entry_form.description.label(class="form-label") }}
                        {{ entry_form.description(class="form-control") }}
                    </div>
                    <div class="row">
                        <div class="col-md-6 mb-3">
                            {{ entry_form.start_time.label(class="form-label") }}
                            {{ entry_form.start_time(class="form-control", id="selectionStartTime") }}
                        </div>
                        <div class="col-md-6 mb-3">
                            {{ entry_form.end_time.label(class="form-label") }}
                            {{ entry_form.end_time(class="form-control", id="selectionEndTime") }}
                        </div>
                    </div>
                    <div class="d-grid gap-2">
                        {{ entry_form.submit(class="btn btn-primary") }}
                    </div>
                </form>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Parse entries data from Jinja
        let allEntries = [];
        
        {% for entry in all_entries %}
        allEntries.push({
            id: {{ entry.id }},
            description: "{{ entry.description }}",
            start_time: new Date("{{ entry.start_time.isoformat() }}"),
            end_time: new Date("{{ entry.end_time.isoformat() }}"),
            date: "{{ entry.start_time.strftime('%Y-%m-%d') }}",
            duration_minutes: {{ entry.duration }}
        });
        {% endfor %}
        
        // Group entries by date
        const entriesByDate = {};
        allEntries.forEach(entry => {
            if (!entriesByDate[entry.date]) {
                entriesByDate[entry.date] = [];
            }
            entriesByDate[entry.date].push(entry);
        });
        
        // Render entries for each day
        Object.keys(entriesByDate).forEach(date => {
            const dayEntries = document.getElementById(`entries-${date}`);
            if (dayEntries) {
                renderDayEntries(dayEntries, entriesByDate[date], date);
            }
        });
        
        // Selection state
        let isSelecting = false;
        let selectionStart = null;
        let selectionCurrentDay = null;
        let selectedSlots = [];
        
        // Drag state
        let isDragging = false;
        let isResizing = false;
        let draggedEntry = null;
        let dragStartY = 0;
        let originalEntryTop = 0;
        let resizeStartY = 0;
        let originalEntryHeight = 0;
        let entryStartTime = null;
        let entryEndTime = null;
        let entryDate = null;
        
        // Time slot selection
        const timeSlots = document.querySelectorAll('.time-slot');
        timeSlots.forEach(slot => {
            slot.addEventListener('mousedown', (e) => {
                // Make sure we're not clicking on an entry or already dragging/resizing
                if (e.button === 0 && !isDragging && !isResizing && !e.target.closest('.time-entry')) {
                    isSelecting = true;
                    selectionStart = slot;
                    selectionCurrentDay = slot.dataset.date;
                    clearSelection();
                    slot.classList.add('selected');
                    selectedSlots.push(slot);
                    
                    // Prevent event from bubbling to parent elements
                    e.stopPropagation();
                }
            });
            
            slot.addEventListener('mouseover', (e) => {
                if (isSelecting && slot.dataset.date === selectionCurrentDay) {
                    updateSelection(selectionStart, slot);
                }
            });
        });
        
        document.addEventListener('mouseup', (e) => {
            if (isSelecting) {
                isSelecting = false;
                if (selectedSlots.length > 0) {
                    showNewEntryFromSelection();
                }
            }
            
            if (isDragging || isResizing) {
                isDragging = false;
                isResizing = false;
                
                if (draggedEntry) {
                    // Save the changes to the server
                    saveEntryChanges(draggedEntry);
                    draggedEntry = null;
                }
            }
        });
        
        // Render entries for a specific day
        function renderDayEntries(container, entries, date) {
            // Clear existing entries
            container.innerHTML = '';
            
            // Render each entry
            entries.forEach(entry => {
                const startHour = entry.start_time.getHours();
                const startMinute = entry.start_time.getMinutes();
                const endHour = entry.end_time.getHours();
                const endMinute = entry.end_time.getMinutes();
                
                // Calculate position and size
                const startPosition = (startHour * 4) + Math.floor(startMinute / 15);
                const endPosition = (endHour * 4) + Math.ceil(endMinute / 15);
                const entryLength = endPosition - startPosition;
                
                // Create entry element
                const entryEl = document.createElement('div');
                entryEl.className = 'time-entry';
                entryEl.style.gridRow = `${startPosition + 1} / span ${entryLength}`;
                entryEl.style.backgroundColor = getRandomColor(entry.description);
                entryEl.dataset.entryId = entry.id;
                entryEl.dataset.startTime = entry.start_time.toISOString();
                entryEl.dataset.endTime = entry.end_time.toISOString();
                entryEl.dataset.date = entry.date;
                entryEl.innerHTML = `
                    <div class="entry-title">${entry.description}</div>
                    <div class="entry-time">${formatTime(entry.start_time)} - ${formatTime(entry.end_time)}</div>
                    <div class="entry-resize-handle"></div>
                `;
                
                // Add event listeners for dragging the entry
                entryEl.addEventListener('mousedown', (e) => {
                    if (e.target.classList.contains('entry-resize-handle')) {
                        // Resize handling
                        e.stopPropagation();
                        isResizing = true;
                        draggedEntry = entryEl;
                        resizeStartY = e.clientY;
                        originalEntryHeight = entryEl.offsetHeight;
                        entryStartTime = new Date(entryEl.dataset.startTime);
                        entryEndTime = new Date(entryEl.dataset.endTime);
                        entryDate = entryEl.dataset.date;
                    } else if (!e.target.closest('a') && !e.target.closest('button')) {
                        // Drag handling (avoid when clicking links or buttons inside the entry)
                        e.stopPropagation();
                        isDragging = true;
                        draggedEntry = entryEl;
                        dragStartY = e.clientY;
                        originalEntryTop = entryEl.offsetTop;
                        entryStartTime = new Date(entryEl.dataset.startTime);
                        entryEndTime = new Date(entryEl.dataset.endTime);
                        entryDate = entryEl.dataset.date;
                        
                        // Highlight the entry being dragged
                        entryEl.classList.add('dragging');
                    }
                });
                
                // Add click handler to show entry details
                entryEl.addEventListener('click', (e) => {
                    if (!isDragging && !isResizing) {
                        showEntryDetails(entry);
                    }
                });
                
                container.appendChild(entryEl);
            });
        }
        
        // Handle mouse move for dragging and resizing
        document.addEventListener('mousemove', (e) => {
            if (isDragging && draggedEntry) {
                const deltaY = e.clientY - dragStartY;
                const slotHeight = 8; // Height of one 15-minute slot in pixels
                const slotsToMove = Math.round(deltaY / slotHeight);
                
                if (slotsToMove !== 0) {
                    // Calculate new times
                    const durationMs = entryEndTime.getTime() - entryStartTime.getTime();
                    const newStartTime = new Date(entryStartTime.getTime() + (slotsToMove * 15 * 60 * 1000));
                    const newEndTime = new Date(newStartTime.getTime() + durationMs);
                    
                    // Update the element's position
                    const startHour = newStartTime.getHours();
                    const startMinute = newStartTime.getMinutes();
                    const endHour = newEndTime.getHours();
                    const endMinute = newEndTime.getMinutes();
                    
                    const startPosition = (startHour * 4) + Math.floor(startMinute / 15);
                    const endPosition = (endHour * 4) + Math.ceil(endMinute / 15);
                    const entryLength = endPosition - startPosition;
                    
                    draggedEntry.style.gridRow = `${startPosition + 1} / span ${entryLength}`;
                    
                    // Update the data attributes
                    draggedEntry.dataset.startTime = newStartTime.toISOString();
                    draggedEntry.dataset.endTime = newEndTime.toISOString();
                    
                    // Update displayed time
                    const timeDisplay = draggedEntry.querySelector('.entry-time');
                    if (timeDisplay) {
                        timeDisplay.textContent = `${formatTime(newStartTime)} - ${formatTime(newEndTime)}`;
                    }
                    
                    // Reset drag start position
                    dragStartY = e.clientY;
                    entryStartTime = newStartTime;
                    entryEndTime = newEndTime;
                }
            } else if (isResizing && draggedEntry) {
                const deltaY = e.clientY - resizeStartY;
                const slotHeight = 8; // Height of one 15-minute slot in pixels
                const slotsToResize = Math.round(deltaY / slotHeight);
                
                if (slotsToResize !== 0) {
                    // Only allow resizing the end time
                    const newEndTime = new Date(entryEndTime.getTime() + (slotsToResize * 15 * 60 * 1000));
                    
                    // Make sure end time is not before start time
                    if (newEndTime > entryStartTime) {
                        // Update the element's size
                        const startHour = entryStartTime.getHours();
                        const startMinute = entryStartTime.getMinutes();
                        const endHour = newEndTime.getHours();
                        const endMinute = newEndTime.getMinutes();
                        
                        const startPosition = (startHour * 4) + Math.floor(startMinute / 15);
                        const endPosition = (endHour * 4) + Math.ceil(endMinute / 15);
                        const entryLength = endPosition - startPosition;
                        
                        draggedEntry.style.gridRow = `${startPosition + 1} / span ${entryLength}`;
                        
                        // Update the data attributes
                        draggedEntry.dataset.endTime = newEndTime.toISOString();
                        
                        // Update displayed time
                        const timeDisplay = draggedEntry.querySelector('.entry-time');
                        if (timeDisplay) {
                            timeDisplay.textContent = `${formatTime(entryStartTime)} - ${formatTime(newEndTime)}`;
                        }
                        
                        // Reset resize start position
                        resizeStartY = e.clientY;
                        entryEndTime = newEndTime;
                    }
                }
            }
        });
        
        // Save entry changes to the server
        function saveEntryChanges(entryEl) {
            const entryId = entryEl.dataset.entryId;
            const startTime = entryEl.dataset.startTime;
            const endTime = entryEl.dataset.endTime;
            
            // Remove the dragging class
            entryEl.classList.remove('dragging');
            
            // Send the update to the server
            fetch('/entry/update', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': '{{ csrf_token() if csrf_token else "" }}'
                },
                body: JSON.stringify({
                    id: entryId,
                    start_time: startTime,
                    end_time: endTime
                })
            })
            .then(response => response.json())
            .then(data => {
                if (!data.success) {
                    console.error('Failed to update entry:', data.message);
                    alert('Failed to update entry: ' + data.message);
                    // Reload the page to refresh the entries
                    window.location.reload();
                }
            })
            .catch(error => {
                console.error('Error updating entry:', error);
                alert('An error occurred while updating the entry. Please try again.');
                // Reload the page to refresh the entries
                window.location.reload();
            });
        }
        
        // Clear current selection
        function clearSelection() {
            selectedSlots.forEach(slot => {
                slot.classList.remove('selected');
            });
            selectedSlots = [];
        }
        
        // Update selection between two slots
        function updateSelection(startSlot, endSlot) {
            clearSelection();
            
            const startHour = parseInt(startSlot.dataset.hour);
            const startMinute = parseInt(startSlot.dataset.minute);
            const endHour = parseInt(endSlot.dataset.hour);
            const endMinute = parseInt(endSlot.dataset.minute);
            const date = startSlot.dataset.date;
            
            // Determine direction
            let start, end;
            if (startHour * 60 + startMinute <= endHour * 60 + endMinute) {
                start = { hour: startHour, minute: startMinute };
                end = { hour: endHour, minute: endMinute };
            } else {
                start = { hour: endHour, minute: endMinute };
                end = { hour: startHour, minute: startMinute };
            }
            
            // Select all slots in range
            document.querySelectorAll(`.time-slot[data-date="${date}"]`).forEach(slot => {
                const hour = parseInt(slot.dataset.hour);
                const minute = parseInt(slot.dataset.minute);
                
                if ((hour > start.hour || (hour === start.hour && minute >= start.minute)) && 
                    (hour < end.hour || (hour === end.hour && minute <= end.minute))) {
                    slot.classList.add('selected');
                    selectedSlots.push(slot);
                }
            });
        }
        
        // Get a deterministic color based on string
        function getRandomColor(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = str.charCodeAt(i) + ((hash << 5) - hash);
            }
            
            const hue = hash % 360;
            return `hsla(${hue}, 70%, 80%, 0.8)`;
        }
        
        // Format time as HH:MM
        function formatTime(date) {
            return date.toTimeString().substring(0, 5);
        }
        
        // Format date as YYYY-MM-DD
        function formatDate(date) {
            return date.toISOString().split('T')[0];
        }
        
        // Show entry details in modal
        function showEntryDetails(entry) {
            document.getElementById('entryInfoDescription').textContent = entry.description;
            document.getElementById('entryInfoDate').textContent = new Date(entry.date).toLocaleDateString();
            document.getElementById('entryInfoStartTime').textContent = formatTime(entry.start_time);
            document.getElementById('entryInfoEndTime').textContent = formatTime(entry.end_time);
            
            // Calculate duration in hours and minutes
            const hours = Math.floor(entry.duration_minutes / 60);
            const minutes = entry.duration_minutes % 60;
            document.getElementById('entryInfoDuration').textContent = 
                `${hours > 0 ? hours + ' hour' + (hours > 1 ? 's' : '') : ''} ${minutes > 0 ? minutes + ' minute' + (minutes > 1 ? 's' : '') : ''}`.trim();
            
            // Set up edit link
            document.getElementById('editEntryLink').href = `/entry/${entry.id}/edit`;
            
            // Set up delete button
            const deleteBtn = document.getElementById('deleteEntryBtn');
            deleteBtn.onclick = () => {
                document.getElementById('deleteEntryName').textContent = entry.description;
                document.getElementById('deleteForm').action = `/entry/${entry.id}/delete`;
                
                const entryInfoModal = bootstrap.Modal.getInstance(document.getElementById('entryInfoModal'));
                entryInfoModal.hide();
                
                const deleteModal = new bootstrap.Modal(document.getElementById('deleteModal'));
                deleteModal.show();
            };
            
            // Show the modal
            const modal = new bootstrap.Modal(document.getElementById('entryInfoModal'));
            modal.show();
        }
        
        // Show new entry modal with selection times pre-filled
        function showNewEntryFromSelection() {
            if (selectedSlots.length === 0) return;
            
            // Find first and last selected slots
            let firstSlot = selectedSlots[0];
            let lastSlot = selectedSlots[selectedSlots.length - 1];
            
            const firstHour = parseInt(firstSlot.dataset.hour);
            const firstMinute = parseInt(firstSlot.dataset.minute);
            const lastHour = parseInt(lastSlot.dataset.hour);
            const lastMinute = parseInt(lastSlot.dataset.minute);
            const date = firstSlot.dataset.date;
            
            // Add 15 minutes to the last slot to get end time
            let endHour = lastHour;
            let endMinute = lastMinute + 15;
            if (endMinute >= 60) {
                endHour++;
                endMinute = 0;
            }
            
            // Set the form values
            const startDateTime = new Date(date);
            startDateTime.setHours(firstHour, firstMinute, 0);
            
            const endDateTime = new Date(date);
            endDateTime.setHours(endHour, endMinute, 0);
            
            // Format for datetime-local input
            const formatForInput = (date) => {
                const localISOString = new Date(date.getTime() - (date.getTimezoneOffset() * 60000))
                    .toISOString()
                    .substring(0, 16);
                return localISOString;
            };
            
            document.getElementById('selectionStartTime').value = formatForInput(startDateTime);
            document.getElementById('selectionEndTime').value = formatForInput(endDateTime);
            
            // Clear the description field
            const descriptionField = document.querySelector('#newEntryFromSelectionForm input[name="description"]');
            if (descriptionField) {
                descriptionField.value = '';
                descriptionField.focus();
            }
            
            // Show the modal
            const modal = new bootstrap.Modal(document.getElementById('newEntryFromSelectionModal'));
            modal.show();
            
            // For debugging
            console.log('Showing new entry modal with:', {
                startTime: formatForInput(startDateTime),
                endTime: formatForInput(endDateTime),
                slots: selectedSlots.length
            });
        }
        // Get z-index correct (entries above slots)
           document.querySelectorAll('.day-entries').forEach(container => {
               container.style.zIndex = 5;
           });
           
           // Debug output for time slots
           console.log('Time slots initialized:', timeSlots.length);
           
           // Log click on time slots for debugging
           timeSlots.forEach(slot => {
               slot.addEventListener('click', (e) => {
                   if (!e.target.closest('.time-entry')) {
                       console.log('Clicked slot:', slot.dataset.date, slot.dataset.time);
                   }
               });
           });
       });
   </script>
{% endblock %}